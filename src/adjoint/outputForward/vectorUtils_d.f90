   !        Generated by TAPENADE     (INRIA, Ecuador team)
   !  Tapenade 3.16 (master) -  9 Oct 2020 17:47
   !
   !  Differentiation of getrotationmatrix3d in forward (tangent) mode (with options noISIZE i4 dr8 r8):
   !   variations   of useful results: mi
   !   with respect to varying inputs: v2
   SUBROUTINE GETROTATIONMATRIX3D_D(v1, v2, v2b, mi, mib)
   USE PRECISION
   USE CONSTANTS
   IMPLICIT NONE
   ! Subroutine Variables
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v1, v2
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v2b
   REAL(kind=realtype), DIMENSION(3, 3), INTENT(OUT) :: mi
   REAL(kind=realtype), DIMENSION(3, 3), INTENT(OUT) :: mib
   ! Local Variables
   REAL(kind=realtype), DIMENSION(3) :: axis, vv1, vv2
   REAL(kind=realtype), DIMENSION(3) :: axisb, vv2b
   REAL(kind=realtype) :: magv1, magv2, axismag, angle, arg
   REAL(kind=realtype) :: magv2b, axismagb, angleb, argb
   REAL(kind=realtype), DIMENSION(3, 3) :: a, c
   REAL(kind=realtype), DIMENSION(3, 3) :: ab, cb
   REAL(kind=realtype), PARAMETER :: tol=1.4901161193847656e-08
   INTRINSIC MIN
   INTRINSIC ACOS
   INTRINSIC SIN
   INTRINSIC COS
   REAL(kind=realtype) :: temp
   REAL(kind=realtype) :: temp0
   REAL(kind=realtype) :: v1b(3)
   CALL GETMAG(v1, magv1)
   CALL GETMAG_D(v2, v2b, magv2, magv2b)
   ! Start by determining the rotation axis by getting the 
   ! cross product between v1, v2
   axisb = 0.0_8
   v1b = 0.0_8
   CALL CROSS_PRODUCT_3D_D(v1, v1b, v2, v2b, axis, axisb)
   ! Now Normalize
   CALL GETMAG_D(axis, axisb, axismag, axismagb)
   ! When axisMag is less that sqrt(eps), the acos 'arg' value will be
   ! exactly one which will give a nan in complex mode. 
   IF (axismag .LT. tol) THEN
   ! no rotation at this point, angle is 0
   angle = zero
   ! the axis doesn't matter so set to x
   axis = zero
   axis(1) = one
   axisb = 0.0_8
   angleb = 0.0_8
   ELSE
   axisb = (axisb-axis*axismagb/axismag)/axismag
   axis = axis/axismag
   ! Now compute the rotation angle about that axis
   vv1 = v1/magv1
   vv2b = (v2b-v2*magv2b/magv2)/magv2
   vv2 = v2/magv2
   IF (one .GT. vv1(1)*vv2(1) + vv1(2)*vv2(2) + vv1(3)*vv2(3)) THEN
   argb = vv1(1)*vv2b(1) + vv1(2)*vv2b(2) + vv1(3)*vv2b(3)
   arg = vv1(1)*vv2(1) + vv1(2)*vv2(2) + vv1(3)*vv2(3)
   ELSE
   arg = one
   argb = 0.0_8
   END IF
   IF (arg .EQ. 1.0 .OR. arg .EQ. (-1.0)) THEN
   angleb = 0.0_8
   ELSE
   angleb = -(argb/SQRT(1.0-arg**2))
   END IF
   angle = ACOS(arg)
   END IF
   ! Now that we have an axis and an angle,build the rotation Matrix
   ! A skew symmetric representation of the normalized axis 
   a(1, 1) = zero
   ab = 0.0_8
   ab(1, 2) = -axisb(3)
   a(1, 2) = -axis(3)
   ab(1, 3) = axisb(2)
   a(1, 3) = axis(2)
   ab(2, 1) = axisb(3)
   a(2, 1) = axis(3)
   ab(2, 2) = 0.0_8
   a(2, 2) = zero
   ab(2, 3) = -axisb(1)
   a(2, 3) = -axis(1)
   ab(3, 1) = -axisb(2)
   a(3, 1) = -axis(2)
   ab(3, 2) = axisb(1)
   a(3, 2) = axis(1)
   ab(3, 3) = 0.0_8
   a(3, 3) = zero
   !C = A*A
   cb = 0.0_8
   cb(1, 1) = 2*a(1, 1)*ab(1, 1) + a(2, 1)*ab(1, 2) + a(1, 2)*ab(2, 1) + &
   &   a(3, 1)*ab(1, 3) + a(1, 3)*ab(3, 1)
   c(1, 1) = a(1, 1)*a(1, 1) + a(1, 2)*a(2, 1) + a(1, 3)*a(3, 1)
   cb(1, 2) = a(1, 2)*ab(1, 1) + (a(1, 1)+a(2, 2))*ab(1, 2) + a(1, 2)*ab(&
   &   2, 2) + a(3, 2)*ab(1, 3) + a(1, 3)*ab(3, 2)
   c(1, 2) = a(1, 1)*a(1, 2) + a(1, 2)*a(2, 2) + a(1, 3)*a(3, 2)
   cb(1, 3) = a(1, 3)*ab(1, 1) + (a(1, 1)+a(3, 3))*ab(1, 3) + a(2, 3)*ab(&
   &   1, 2) + a(1, 2)*ab(2, 3) + a(1, 3)*ab(3, 3)
   c(1, 3) = a(1, 1)*a(1, 3) + a(1, 2)*a(2, 3) + a(1, 3)*a(3, 3)
   cb(2, 1) = (a(1, 1)+a(2, 2))*ab(2, 1) + a(2, 1)*ab(1, 1) + a(2, 1)*ab(&
   &   2, 2) + a(3, 1)*ab(2, 3) + a(2, 3)*ab(3, 1)
   c(2, 1) = a(2, 1)*a(1, 1) + a(2, 2)*a(2, 1) + a(2, 3)*a(3, 1)
   cb(2, 2) = a(1, 2)*ab(2, 1) + a(2, 1)*ab(1, 2) + 2*a(2, 2)*ab(2, 2) + &
   &   a(3, 2)*ab(2, 3) + a(2, 3)*ab(3, 2)
   c(2, 2) = a(2, 1)*a(1, 2) + a(2, 2)*a(2, 2) + a(2, 3)*a(3, 2)
   cb(2, 3) = a(1, 3)*ab(2, 1) + a(2, 1)*ab(1, 3) + a(2, 3)*ab(2, 2) + (a&
   &   (2, 2)+a(3, 3))*ab(2, 3) + a(2, 3)*ab(3, 3)
   c(2, 3) = a(2, 1)*a(1, 3) + a(2, 2)*a(2, 3) + a(2, 3)*a(3, 3)
   cb(3, 1) = (a(1, 1)+a(3, 3))*ab(3, 1) + a(3, 1)*ab(1, 1) + a(2, 1)*ab(&
   &   3, 2) + a(3, 2)*ab(2, 1) + a(3, 1)*ab(3, 3)
   c(3, 1) = a(3, 1)*a(1, 1) + a(3, 2)*a(2, 1) + a(3, 3)*a(3, 1)
   cb(3, 2) = a(1, 2)*ab(3, 1) + a(3, 1)*ab(1, 2) + (a(2, 2)+a(3, 3))*ab(&
   &   3, 2) + a(3, 2)*ab(2, 2) + a(3, 2)*ab(3, 3)
   c(3, 2) = a(3, 1)*a(1, 2) + a(3, 2)*a(2, 2) + a(3, 3)*a(3, 2)
   cb(3, 3) = a(1, 3)*ab(3, 1) + a(3, 1)*ab(1, 3) + a(2, 3)*ab(3, 2) + a(&
   &   3, 2)*ab(2, 3) + 2*a(3, 3)*ab(3, 3)
   c(3, 3) = a(3, 1)*a(1, 3) + a(3, 2)*a(2, 3) + a(3, 3)*a(3, 3)
   ! Rodrigues formula for the rotation matrix 
   mi = zero
   mi(1, 1) = one
   mi(2, 2) = one
   mi(3, 3) = one
   temp = SIN(angle)
   temp0 = one - COS(angle)
   mib = (a*COS(angle)+c*SIN(angle))*angleb + temp*ab + temp0*cb
   mi = mi + temp*a + temp0*c
   END SUBROUTINE GETROTATIONMATRIX3D_D
      !  Differentiation of cross_product_3d in forward (tangent) mode (with options noISIZE i4 dr8 r8):
   !   variations   of useful results: cross
   !   with respect to varying inputs: cross v1 v2
   ! ====================================================================
   ! File: vectorUtils.f90
   ! Author: C.A.(Sandy) Mader
   ! Date Started: July 14, 2014
   ! Date Modified:
   SUBROUTINE CROSS_PRODUCT_3D_D(v1, v1b, v2, v2b, cross, crossb)
   USE CONSTANTS
   IMPLICIT NONE
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v1, v2
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v1b, v2b
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: cross
   REAL(kind=realtype), DIMENSION(3), INTENT(OUT) :: crossb
   crossb(1) = v2(3)*v1b(2) + v1(2)*v2b(3) - v2(2)*v1b(3) - v1(3)*v2b(2)
   cross(1) = v1(2)*v2(3) - v1(3)*v2(2)
   crossb(2) = v2(1)*v1b(3) + v1(3)*v2b(1) - v2(3)*v1b(1) - v1(1)*v2b(3)
   cross(2) = v1(3)*v2(1) - v1(1)*v2(3)
   crossb(3) = v2(2)*v1b(1) + v1(1)*v2b(2) - v2(1)*v1b(2) - v1(2)*v2b(1)
   cross(3) = v1(1)*v2(2) - v1(2)*v2(1)
   END SUBROUTINE CROSS_PRODUCT_3D_D
      !  Differentiation of getmag in forward (tangent) mode (with options noISIZE i4 dr8 r8):
   !   variations   of useful results: mag
   !   with respect to varying inputs: v
   SUBROUTINE GETMAG_D(v, vb, mag, magb)
   USE CONSTANTS
   IMPLICIT NONE
   ! Subroutine Variables
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: vb
   REAL(kind=realtype), INTENT(OUT) :: mag
   REAL(kind=realtype), INTENT(OUT) :: magb
   INTRINSIC SQRT
   REAL(kind=realtype) :: arg1
   REAL(kind=realtype) :: arg1b
   REAL(kind=realtype) :: temp
   arg1b = 2*v(1)*vb(1) + 2*v(2)*vb(2) + 2*v(3)*vb(3)
   arg1 = v(1)**2 + v(2)**2 + v(3)**2 + 1e-30
   temp = SQRT(arg1)
   IF (arg1 .EQ. 0.0_8) THEN
   magb = 0.0_8
   ELSE
   magb = arg1b/(2.0*temp)
   END IF
   mag = temp
   END SUBROUTINE GETMAG_D
