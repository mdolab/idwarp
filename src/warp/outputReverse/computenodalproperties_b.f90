!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
!
!  Differentiation of computenodalproperties in reverse (adjoint) mode (with options noISIZE i4 dr8 r8):
!   gradient     of useful results: *bi
!   with respect to varying inputs: *xsptr
!   Plus diff mem management of: xsptr:in xu:in bi:in normals:in
!                mi:in
SUBROUTINE COMPUTENODALPROPERTIES_B(initialpoint)
  USE GRIDINPUT
  USE COMMUNICATION
  USE GRIDDATA
  IMPLICIT NONE
  ! Subroutine Variable
  LOGICAL :: initialpoint
  ! Working variables
  REAL(kind=realtype), DIMENSION(3, 20) :: points
  REAL(kind=realtype), DIMENSION(3, 20) :: pointsb
  INTEGER(kind=inttype) :: i, j, jj, kk, npts, nelem, ind
  INTEGER(kind=inttype) :: nptsmax
  REAL(kind=realtype) :: facearea, facenormal(3)
  REAL(kind=realtype) :: faceareab, facenormalb(3)
  REAL(kind=realtype) :: sumarea, sumnormal(3), si(3), ds(3), smean(3), &
       &  da, eta, r(3), dx(3)
  REAL(kind=realtype) :: sumareab, sumnormalb(3), dab
  INTEGER :: ad_to
  ! This performs the copy and mirroring as required
  DO i=1,nunique
     j = xuind(i)
     xu(:, i) = xsptr(3*j-2:3*j)*xufact(:, i)
  END DO
  ! Now we loop over nodes and fill up Ai, Bi, and Mi
  normals = zero
  xub = 0.0_8
  normalsb = 0.0_8
  mib = 0.0_8
  pointsb = 0.0_8
  DO i=1,nunique
     sumarea = zero
     sumnormal = zero
     nelem = nodetoelem(1, i)
     DO jj=1,nelem
        ind = nodetoelem(1+jj, i)
        ! Extract points for this face
        npts = faceptr(ind) - faceptr(ind-1)
        DO kk=1,npts
           CALL PUSHREAL8ARRAY(points(:, kk), realtype*3/8)
           points(:, kk) = xu(:, faceconn(faceptr(ind-1)+kk))
        END DO
        CALL PUSHINTEGER4(kk - 1)
        CALL PUSHREAL8ARRAY(facenormal, realtype*3/8)
        CALL GETELEMENTPROPS(points, npts, facearea, facenormal)
        CALL PUSHREAL8ARRAY(da, realtype/8)
        ! For face 'ind' how many nodes are on the element?
        da = facearea/(faceptr(ind)-faceptr(ind-1))
        sumarea = sumarea + da
        sumnormal = sumnormal + da*facenormal
     END DO
     normals(:, i) = sumnormal/sumarea
     IF (.NOT.initialpoint) THEN
        ! Now get the rotation Matrix
        IF (userotations) THEN
           xub(:, i) = xub(:, i) + bib(:, i)
           mib(:, 1, i) = mib(:, 1, i) - xu0(1, i)*bib(:, i)
           mib(:, 2, i) = mib(:, 2, i) - xu0(2, i)*bib(:, i)
           mib(:, 3, i) = mib(:, 3, i) - xu0(3, i)*bib(:, i)
           bib(:, i) = 0.0_8
        ELSE
           xub(:, i) = xub(:, i) + bib(:, i)
           bib(:, i) = 0.0_8
        END IF
        CALL GETROTATIONMATRIX3D_B(normals0(:, i), normals(:, i), normalsb&
             &                           (:, i), mi(:, :, i), mib(:, :, i))
        mib(:, :, i) = 0.0_8
     END IF
     sumnormalb = 0.0_8
     sumnormalb = normalsb(:, i)/sumarea
     sumareab = SUM(-(sumnormal*normalsb(:, i)/sumarea))/sumarea
     normalsb(:, i) = 0.0_8
     DO jj=nelem,1,-1
        facenormalb = 0.0_8
        dab = sumareab + SUM(facenormal*sumnormalb)
        facenormalb = da*sumnormalb
        ind = nodetoelem(1+jj, i)
        CALL POPREAL8ARRAY(da, realtype/8)
        faceareab = dab/(faceptr(ind)-faceptr(ind-1))
        npts = faceptr(ind) - faceptr(ind-1)
        CALL POPREAL8ARRAY(facenormal, realtype*3/8)
        CALL GETELEMENTPROPS_B(points, pointsb, npts, facearea, faceareab&
             &                       , facenormal, facenormalb)
        CALL POPINTEGER4(ad_to)
        DO kk=ad_to,1,-1
           CALL POPREAL8ARRAY(points(:, kk), realtype*3/8)
           xub(:, faceconn(faceptr(ind-1)+kk)) = xub(:, faceconn(faceptr(&
                &          ind-1)+kk)) + pointsb(:, kk)
           pointsb(:, kk) = 0.0_8
        END DO
     END DO
  END DO
  xsptrb = 0.0_8
  DO i=nunique,1,-1
     j = xuind(i)
     xsptrb(3*j-2:3*j) = xsptrb(3*j-2:3*j) + xufact(:, i)*xub(:, i)
     xub(:, i) = 0.0_8
  END DO
END SUBROUTINE COMPUTENODALPROPERTIES_B
