   !        Generated by TAPENADE     (INRIA, Tropics team)
   !  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
   !
   !  Differentiation of getrotationmatrix3d in forward (tangent) mode (with options noISIZE i4 dr8 r8):
   !   variations   of useful results: mi
   !   with respect to varying inputs: v2
   SUBROUTINE GETROTATIONMATRIX3D_D(v1, v2, v2b, mi, mib)
   USE PRECISION
   USE CONSTANTS
   IMPLICIT NONE
   ! Subroutine Variables
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v1, v2
   REAL(kind=realtype), DIMENSION(3), INTENT(IN) :: v2b
   REAL(kind=realtype), DIMENSION(3, 3), INTENT(OUT) :: mi
   REAL(kind=realtype), DIMENSION(3, 3), INTENT(OUT) :: mib
   ! Local Variables
   REAL(kind=realtype), DIMENSION(3) :: axis, vv1, vv2
   REAL(kind=realtype), DIMENSION(3) :: axisb, vv2b
   REAL(kind=realtype) :: magv1, magv2, axismag, angle, arg
   REAL(kind=realtype) :: magv2b, axismagb, angleb, argb
   REAL(kind=realtype), DIMENSION(3, 3) :: a, c
   REAL(kind=realtype), DIMENSION(3, 3) :: ab, cb
   REAL(kind=realtype), PARAMETER :: tol=1.4901161193847656e-08
   INTRINSIC MIN
   INTRINSIC ACOS
   INTRINSIC SIN
   INTRINSIC COS
   REAL(kind=realtype) :: v1b(3)
   CALL GETMAG(v1, magv1)
   CALL GETMAG_D(v2, v2b, magv2, magv2b)
   ! Start by determining the rotation axis by getting the 
   ! cross product between v1, v2
   axisb = 0.0_8
   v1b = 0.0_8
   CALL CROSS_PRODUCT_3D_D(v1, v1b, v2, v2b, axis, axisb)
   ! Now Normalize
   CALL GETMAG_D(axis, axisb, axismag, axismagb)
   ! When axisMag is less that sqrt(eps), the acos 'arg' value will be
   ! exactly one which will give a nan in complex mode. 
   IF (axismag .LT. tol) THEN
   ! no rotation at this point, angle is 0
   angle = zero
   ! the axis doesn't matter so set to x
   axis = zero
   axis(1) = one
   axisb = 0.0_8
   angleb = 0.0_8
   ELSE
   axisb = (axisb*axismag-axis*axismagb)/axismag**2
   axis = axis/axismag
   ! Now compute the rotation angle about that axis
   vv1 = v1/magv1
   vv2b = (v2b*magv2-v2*magv2b)/magv2**2
   vv2 = v2/magv2
   IF (one .GT. vv1(1)*vv2(1) + vv1(2)*vv2(2) + vv1(3)*vv2(3)) THEN
   argb = vv1(1)*vv2b(1) + vv1(2)*vv2b(2) + vv1(3)*vv2b(3)
   arg = vv1(1)*vv2(1) + vv1(2)*vv2(2) + vv1(3)*vv2(3)
   ELSE
   arg = one
   argb = 0.0_8
   END IF
   IF (arg .EQ. 1.0 .OR. arg .EQ. (-1.0)) THEN
   angleb = 0.0_8
   ELSE
   angleb = -(argb/SQRT(1.0-arg**2))
   END IF
   angle = ACOS(arg)
   END IF
   ! Now that we have an axis and an angle,build the rotation Matrix
   ! A skew symmetric representation of the normalized axis 
   a(1, 1) = zero
   ab = 0.0_8
   ab(1, 2) = -axisb(3)
   a(1, 2) = -axis(3)
   ab(1, 3) = axisb(2)
   a(1, 3) = axis(2)
   ab(2, 1) = axisb(3)
   a(2, 1) = axis(3)
   ab(2, 2) = 0.0_8
   a(2, 2) = zero
   ab(2, 3) = -axisb(1)
   a(2, 3) = -axis(1)
   ab(3, 1) = -axisb(2)
   a(3, 1) = -axis(2)
   ab(3, 2) = axisb(1)
   a(3, 2) = axis(1)
   ab(3, 3) = 0.0_8
   a(3, 3) = zero
   !C = A*A
   cb = 0.0_8
   cb(1, 1) = ab(1, 1)*a(1, 1) + a(1, 1)*ab(1, 1) + ab(1, 2)*a(2, 1) + a(&
   &   1, 2)*ab(2, 1) + ab(1, 3)*a(3, 1) + a(1, 3)*ab(3, 1)
   c(1, 1) = a(1, 1)*a(1, 1) + a(1, 2)*a(2, 1) + a(1, 3)*a(3, 1)
   cb(1, 2) = ab(1, 1)*a(1, 2) + a(1, 1)*ab(1, 2) + ab(1, 2)*a(2, 2) + a(&
   &   1, 2)*ab(2, 2) + ab(1, 3)*a(3, 2) + a(1, 3)*ab(3, 2)
   c(1, 2) = a(1, 1)*a(1, 2) + a(1, 2)*a(2, 2) + a(1, 3)*a(3, 2)
   cb(1, 3) = ab(1, 1)*a(1, 3) + a(1, 1)*ab(1, 3) + ab(1, 2)*a(2, 3) + a(&
   &   1, 2)*ab(2, 3) + ab(1, 3)*a(3, 3) + a(1, 3)*ab(3, 3)
   c(1, 3) = a(1, 1)*a(1, 3) + a(1, 2)*a(2, 3) + a(1, 3)*a(3, 3)
   cb(2, 1) = ab(2, 1)*a(1, 1) + a(2, 1)*ab(1, 1) + ab(2, 2)*a(2, 1) + a(&
   &   2, 2)*ab(2, 1) + ab(2, 3)*a(3, 1) + a(2, 3)*ab(3, 1)
   c(2, 1) = a(2, 1)*a(1, 1) + a(2, 2)*a(2, 1) + a(2, 3)*a(3, 1)
   cb(2, 2) = ab(2, 1)*a(1, 2) + a(2, 1)*ab(1, 2) + ab(2, 2)*a(2, 2) + a(&
   &   2, 2)*ab(2, 2) + ab(2, 3)*a(3, 2) + a(2, 3)*ab(3, 2)
   c(2, 2) = a(2, 1)*a(1, 2) + a(2, 2)*a(2, 2) + a(2, 3)*a(3, 2)
   cb(2, 3) = ab(2, 1)*a(1, 3) + a(2, 1)*ab(1, 3) + ab(2, 2)*a(2, 3) + a(&
   &   2, 2)*ab(2, 3) + ab(2, 3)*a(3, 3) + a(2, 3)*ab(3, 3)
   c(2, 3) = a(2, 1)*a(1, 3) + a(2, 2)*a(2, 3) + a(2, 3)*a(3, 3)
   cb(3, 1) = ab(3, 1)*a(1, 1) + a(3, 1)*ab(1, 1) + ab(3, 2)*a(2, 1) + a(&
   &   3, 2)*ab(2, 1) + ab(3, 3)*a(3, 1) + a(3, 3)*ab(3, 1)
   c(3, 1) = a(3, 1)*a(1, 1) + a(3, 2)*a(2, 1) + a(3, 3)*a(3, 1)
   cb(3, 2) = ab(3, 1)*a(1, 2) + a(3, 1)*ab(1, 2) + ab(3, 2)*a(2, 2) + a(&
   &   3, 2)*ab(2, 2) + ab(3, 3)*a(3, 2) + a(3, 3)*ab(3, 2)
   c(3, 2) = a(3, 1)*a(1, 2) + a(3, 2)*a(2, 2) + a(3, 3)*a(3, 2)
   cb(3, 3) = ab(3, 1)*a(1, 3) + a(3, 1)*ab(1, 3) + ab(3, 2)*a(2, 3) + a(&
   &   3, 2)*ab(2, 3) + ab(3, 3)*a(3, 3) + a(3, 3)*ab(3, 3)
   c(3, 3) = a(3, 1)*a(1, 3) + a(3, 2)*a(2, 3) + a(3, 3)*a(3, 3)
   ! Rodrigues formula for the rotation matrix 
   mi = zero
   mi(1, 1) = one
   mi(2, 2) = one
   mi(3, 3) = one
   mib = angleb*COS(angle)*a + SIN(angle)*ab + angleb*SIN(angle)*c + (one&
   &   -COS(angle))*cb
   mi = mi + SIN(angle)*a + (one-COS(angle))*c
   END SUBROUTINE GETROTATIONMATRIX3D_D
