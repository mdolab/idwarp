!    -*- f90 -*-
! Note: the context of this file is case sensitive.
#ifdef USE_COMPLEX
python module warpustruct_cs ! in 
#else
python module warpustruct ! in 
#endif
    interface  ! in :warpustruct

       subroutine initpetsc(comm)
         integer(kind=inttype) :: comm
       end subroutine initpetsc

       subroutine createcommongrid(volnodes,wallnodes,nvollocal) ! in :test:createGrid.F90
         real(kind=realtype) dimension(3,nvollocal),intent(in) :: volnodes
         integer(kind=inttype) dimension(nvollocal),intent(in),depend(nvollocal) :: wallnodes
         integer(kind=inttype), optional,intent(in),check(shape(volnodes,1)==nvollocal),depend(volnodes) :: nvollocal=shape(volnodes,1)
       end subroutine createcommongrid

       subroutine getnpatchesstructured(npatches) ! in :warpustruct:../IO/patchIO.f90
            integer(kind=inttype) intent(out) :: npatches
        end subroutine getnpatchesstructured

        subroutine getpatchnamestructured(ipatch,patchname) ! in :warpustruct:../IO/patchIO.f90
            integer(kind=inttype) intent(in) :: ipatch
            character*32 intent(out) :: patchname
        end subroutine getpatchnamestructured

        subroutine getpatchsizestructured(ipatch,patchsize) ! in :warpustruct:../IO/patchIO.f90
            integer(kind=inttype) intent(in) :: ipatch
            integer(kind=inttype) dimension(2),intent(out) :: patchsize
        end subroutine getpatchsizestructured

        subroutine getnpatchesunstructured(npatches) ! in :warpustruct:../IO/patchIO.F90
            integer(kind=inttype) intent(out) :: npatches
        end subroutine getnpatchesunstructured

        subroutine getpatchnameunstructured(ipatch,patchname) ! in :warpustruct:../IO/patchIO.F90
            integer(kind=inttype) intent(in) :: ipatch
            character*32 intent(out) :: patchname
        end subroutine getpatchnameunstructured

        subroutine getpatchsizesunstructured(ipatch,npts,ncells) ! in :warpustruct:../IO/patchIO.F90
            integer(kind=inttype) intent(in) :: ipatch
            integer(kind=inttype) intent(out) :: npts
            integer(kind=inttype) intent(out) :: ncells
        end subroutine getpatchsizesunstructured

       subroutine getpatchdataunstructured(cgns_file,facesizes,nfaces,conn,nconnpts,patchptr,patchsize,points,ndof) ! in :warpustruct:../IO/patchIO.F90
            character*(*) intent(in) :: cgns_file
            integer(kind=inttype) dimension(nfaces),intent(inout) :: facesizes
            integer(kind=inttype), optional,intent(in),check(len(facesizes)>=nfaces),depend(facesizes) :: nfaces=len(facesizes)
            integer(kind=inttype) dimension(nconnpts),intent(inout) :: conn
            integer(kind=inttype), optional,intent(in),check(len(conn)>=nconnpts),depend(conn) :: nconnpts=len(conn)
            integer(kind=inttype) dimension(patchsize),intent(inout) :: patchptr
            integer(kind=inttype), optional,intent(in),check(len(patchptr)>=patchsize),depend(patchptr) :: patchsize=len(patchptr)
            real(kind=realtype) dimension(ndof),intent(inout) :: points
            integer(kind=inttype), optional,intent(in),check(len(points)>=ndof),depend(points) :: ndof=len(points)
        end subroutine getpatchdataunstructured
       subroutine readstructuredcgns(cgns_file)
         character*(*) :: cgns_file
       end subroutine readstructuredcgns
       subroutine readunstructuredcgns(cgns_file) ! in :warpustruct:../IO/readUnstructuredCGNS.f90
            character*(*) intent(in) :: cgns_file
        end subroutine readunstructuredcgns
        ! subroutine writeunstructuredcgnsfile ! in :warpustruct:../IO/writeUnstructuredCGNS.f90
        !     use griddata
        !     use communication
        !     use precision
        ! end subroutine writeunstructuredcgnsfile
       subroutine setexternalmeshindices(ndof_solver,solver_indices)
         integer(kind=inttype) optional,intent(in),check(len(solver_indices)>=ndof_solver),depend(solver_indices) :: ndof_solver=len(solver_indices)
         integer(kind=inttype) dimension(ndof_solver),intent(in) :: solver_indices
       end subroutine setexternalmeshindices
       
       subroutine getvolumecoordinates(gridnodes,ndof) ! in getVolumeCoordinates.F90
         real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: gridnodes
         integer(kind=inttype) intent(in) :: ndof
       end subroutine getvolumecoordinates
       
       subroutine setvolumecoordinates(gridnodes,ndof) ! in getVolumeCoordinates.F90
         real(kind=realtype) dimension(ndof),intent(in) :: gridnodes
         integer(kind=inttype), optional,intent(in),check(len(gridnodes)>=ndof),depend(gridnodes) :: ndof=len(gridnodes)
       end subroutine setvolumecoordinates

       subroutine getcommonvolumecoordinates(gridnodes,ndof) ! in getCommonvolumeCoordinates.F90
         real(kind=realtype) dimension(ndof),intent(out),depend(ndof) :: gridnodes
         integer(kind=inttype) intent(in) :: ndof
       end subroutine getcommonvolumecoordinates
       
       subroutine setcommonvolumecoordinates(gridnodes,ndof) ! in getCommonvolumeCoordinates.F90
         real(kind=realtype) dimension(ndof),intent(in) :: gridnodes
         integer(kind=inttype), optional,intent(in),check(len(gridnodes)>=ndof),depend(gridnodes) :: ndof=len(gridnodes)
       end subroutine setcommonvolumecoordinates
       
       subroutine initializewarping(pts,ndof,facesizeslocal,faceconnlocal,nfacesizeslocal,nfaceconnlocal) ! in :test:initializeWarping.F90
         real(kind=realtype) dimension(ndof),intent(in) :: pts
         integer(kind=inttype), optional,intent(in),check(len(pts)>=ndof),depend(pts) :: ndof=len(pts)
         integer(kind=inttype) dimension(nfacesizeslocal),intent(in) :: facesizeslocal
         integer(kind=inttype) dimension(nfaceconnlocal),intent(in) :: faceconnlocal
         integer(kind=inttype), optional,intent(in),check(len(facesizeslocal)>=nfacesizeslocal),depend(facesizeslocal) :: nfacesizeslocal=len(facesizeslocal)
         integer(kind=inttype), optional,intent(in),check(len(faceconnlocal)>=nfaceconnlocal),depend(faceconnlocal) :: nfaceconnlocal=len(faceconnlocal)
       end subroutine initializewarping

       subroutine warpmesh()
       end subroutine warpmesh

       subroutine setsurfacecoordinates(indices,idof,coordinates, cdof) ! in :test:setSurfaceCoordinatesLocal.f90
         integer(kind=inttype) dimension(idof),intent(in) :: indices
         integer(kind=inttype) optional,intent(in),check(len(indices)>=idof),depend(indices) :: idof=len(indices)
         real(kind=realtype) dimension(cdof),intent(in) :: coordinates
         integer(kind=inttype) optional,intent(in),check(len(coordinates)>=cdof),depend(coordinates) :: cdof=len(coordinates)
       end subroutine setsurfacecoordinates
     
       subroutine getsurfacecoordinates(indices,idof,coordinates,cdof) ! in :test:getSurfaceCoordinates.F90
         integer(kind=inttype) dimension(idof),intent(in) :: indices
         integer(kind=inttype) optional,intent(in),check(len(indices)>=idof),depend(indices) :: idof=len(indices)
         real(kind=realtype) dimension(cdof),intent(inout) :: coordinates
         integer(kind=inttype) optional,intent(in),check(len(coordinates)>=cdof),depend(coordinates) :: cdof=len(coordinates)
       end subroutine getsurfacecoordinates
       
       subroutine warp_to_solver_grid(warp_grid,wdof,solver_grid,sdof) ! in :test:gridTransform.F90
         real(kind=realtype) dimension(wdof),intent(in) :: warp_grid
         integer(kind=inttype) optional,intent(in),check(len(warp_grid)>=wdof),depend(warp_grid) :: wdof=len(warp_grid)
         real(kind=realtype) dimension(sdof),intent(inout) :: solver_grid
         integer(kind=inttype) optional,intent(in),check(len(solver_grid)>=sdof),depend(solver_grid) :: sdof=len(solver_grid)
       end subroutine warp_to_solver_grid

       subroutine solver_to_warp_grid(solver_grid,sdof,warp_grid,wdof) ! in :test:gridTransform.F90
         real(kind=realtype) dimension(sdof),intent(in) :: solver_grid
         integer(kind=inttype) optional,intent(in),check(len(solver_grid)>=sdof),depend(solver_grid) :: sdof=len(solver_grid)
         real(kind=realtype) dimension(wdof),intent(inout) :: warp_grid
         integer(kind=inttype) optional,intent(in),check(len(warp_grid)>=wdof),depend(warp_grid) :: wdof=len(warp_grid)
       end subroutine solver_to_warp_grid

       subroutine warpderiv(dxv_f,ndof_warp)
         real(kind=realtype) dimension(ndof_warp) :: dxv_f
         integer(kind=inttype) optional,check(len(dxv_f)>=ndof_warp),depend(dxv_f) :: ndof_warp=len(dxv_f)
       end subroutine warpderiv

       subroutine warpderivfwd(indices,idof,xsdot,cdof,outvec,warpmeshdof) ! in :test:warpMeshd.F90
         integer(kind=inttype) dimension(idof),intent(in) :: indices
         integer(kind=inttype), optional,intent(in),check(len(indices)>=idof),depend(indices) :: idof=len(indices)
         real(kind=realtype) dimension(cdof),intent(in) :: xsdot
         integer(kind=inttype), optional,intent(in),check(len(xsdot)>=cdof),depend(xsdot) :: cdof=len(xsdot)
         real(kind=realtype) dimension(warpmeshdof),intent(inout) :: outvec
         integer(kind=inttype), optional,intent(in),check(len(outvec)>=warpmeshdof),depend(outvec) :: warpmeshdof=len(outvec)
       end subroutine warpderivfwd

       subroutine warpderivsurfonly(dxv_f,ndof)
         real(kind=realtype) dimension(ndof) :: dxv_f
         integer(kind=inttype) optional,check(len(dxv_f)>=ndof),depend(dxv_f) :: ndof=len(dxv_f)
       end subroutine warpderivsurfonly

       subroutine getdxs(indices,idof,output,ndof) ! in :test:getdXs.F90
         integer(kind=inttype) dimension(idof),intent(in) :: indices
         integer(kind=inttype) optional,intent(in),check(len(indices)>=idof),depend(indices) :: idof=len(indices)
         real(kind=realtype) dimension(ndof),intent(inout) :: output
         integer(kind=inttype) optional,intent(in),check(len(output)>=ndof),depend(output) :: ndof=len(output)
       end subroutine getdxs
       
       subroutine setdxs(indices,idof,in_vec,ndof) ! in :test:setdXs.F90
         integer(kind=inttype) dimension(idof),intent(in) :: indices
         integer(kind=inttype) optional,intent(in),check(len(indices)>=idof),depend(indices) :: idof=len(indices)
         real(kind=realtype) dimension(ndof),intent(in) :: in_vec
         integer(kind=inttype) optional,intent(in),check(len(in_vec)>=ndof),depend(in_vec) :: ndof=len(in_vec)
       end subroutine setdxs

       subroutine verifywarpderiv(dxv_f,ndof_warp,dof_start,dof_end,h) ! in :test:warpDeriv.F90
         real(kind=realtype) dimension(ndof_warp) :: dxv_f
         integer(kind=inttype) optional,check(len(dxv_f)>=ndof_warp),depend(dxv_f) :: ndof_warp=len(dxv_f)
         integer(kind=inttype), intent(in) :: dof_start
         integer(kind=inttype), intent(in) :: dof_end
         real(kind=realtype), intent(in) :: h
       end subroutine verifywarpderiv

       subroutine writestructuredcgns(cgns_file)
         character*(*) :: cgns_file
       end subroutine writestructuredcgns

       subroutine releasememory
       end subroutine releasememory

       module gridinput
         real(kind=realtype) :: aexp
         real(kind=realtype) :: bexp
         integer(kind=inttype) :: isymm
         real(kind=realtype) :: alpha
         real(kind=realtype) :: ldeffact
         real(kind=realtype) :: symmtol
         real(kind=realtype) :: errtol
         logical :: userotations
         integer(kind=inttype) :: evalmode
         integer(kind=inttype) :: eval_exact = 0
         integer(kind=inttype) :: eval_fast = 1
       end module gridinput

       module griddata ! in :warpustruct:../modules/gridData.f90
         use constants
         character dimension(32,32),intent(c) :: familylist
         integer(kind=inttype) :: nwallfamilies
         integer(kind=inttype) :: warpmeshdof
         integer(kind=inttype) :: solvermeshdof
         integer(Kind=inttype) :: commonmeshdof
       end module griddata

       module structuredcgnsgrid
         real(kind=realtype), dimension(:), allocatable :: wallpoints
         integer(kind=inttype), dimension(:), allocatable :: wallconn
       end module structuredcgnsgrid

       module kd_tree
         integer(kind=inttype) :: bucket_size
       end module kd_tree
       
    end interface 
#ifdef USE_COMPLEX
end python module warpustruct_cs
#else
end python module warpustruct
#endif

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
